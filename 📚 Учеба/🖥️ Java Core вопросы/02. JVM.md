- [[#За что отвечает JVM|За что отвечает JVM]]
	- [[#За что отвечает JVM#С какими типами данных работает JVM|С какими типами данных работает JVM]]
- [[#Classloader|Classloader]]
- [[#Области данных времени выполнения|Области данных времени выполнения]]
	- [[#Области данных времени выполнения#The pc Register (PCR)|The pc Register (PCR)]]
	- [[#Области данных времени выполнения#Java Virtual Machine Stacks|Java Virtual Machine Stacks]]
	- [[#Области данных времени выполнения#Heap|Heap]]
	- [[#Области данных времени выполнения#Method Area|Method Area]]
	- [[#Области данных времени выполнения#Run-Time Constant Pool|Run-Time Constant Pool]]
	- [[#Области данных времени выполнения#Native Method Stacks|Native Method Stacks]]
- [[#Frames|Frames]]

---

## За что отвечает JVM

- Загрузка, проверка и исполнение байт кода;
	
- Предоставление среды выполнения для выполнения байт-кода;
	
- Управление памятью и очисткой мусора (Garbage collection);

***Виртуальная машина Java (Java Virtual Machine)*** - это механизм, предоставляющий среду выполнения для управления Java-кодом или приложениями. Виртуальная машина является **независимой оболочкой исполнения кода**, благодаря которой возможен её запуск на **любой ОС**, без влияния ОС на выполняемую программу.

### С какими типами данных работает JVM

JVM работает с 2мя типами данных: примитивные типы (**primitive types**) и ссылочные типы (**reference types**).

*Примитивы:*

JVM работает с примитивными значениями (целыми числами и числами с плавающей точкой). По сути, JVM - это 32-битная машина. Типы `long` и `double`, которые являются 64-битными, поддерживаются изначально, но занимают две единицы памяти в `frame's local` или стеке операндов, поскольку каждая единица составляет 32 бита. Типы `boolean`, `byte`, `short` и `char` имеют расширенный знак (кроме `char` с нулевым расширением) и работают как 32-разрядные целые числа, так же, как и типы `int`. Меньшие типы имеют только несколько специфических для типа инструкций для загрузки, хранения и преобразования типов. `boolean` значение работает как 8-битное `byte` значения, где 0 представляет значение **false**, а 1 - значение **true**.

*Типы ссылок и значения:*

Существует три типа ссылочных типов: типы классов, типы массивов и типы интерфейсов. Их значения являются ссылками на динамически создаваемые экземпляры классов, массивы или экземпляры классов, которые реализуют интерфейсы соответственно.

## Classloader

***Загрузчик классов*** является частью *JRE (Java Runtime Environment, среда выполнения Java, часть программного обеспечения, которая предназначена для запуска другого программного обеспечения)*, которая динамически загружает Java классы в JVM.
Обычно классы загружаются только по запросу. Система исполнения в Java не должна знать о файлах и файловых системах благодаря загрузчику классов. 
*Делегирование* является важной концепцией, которую выполняет **загрузчик**. Загрузчик классов отвечает за поиск библиотек, чтение их содержимого и загрузку классов, содержащихся в библиотеках. Эта загрузка обычно выполняется **«по требованию»**, поскольку она не происходит до тех пор, пока программа не вызовет класс.
**Класс с именем может быть загружен только один раз данным загрузчиком классов.**

При запуске JVM, используются **три загрузчика классов**:
- Bootstrap class loader (Загрузчик класса Bootstrap)
- Extensions class loader (Загрузчик класса расширений)
- System class loader (Системный загрузчик классов)

## Области данных времени выполнения

***Run-Time Data Areas***. JVM выделяет множество областей данных во время выполнения, которые используются во время выполнения программы. Некоторые участки данных созданы JVM во время старта и уничтожаются во время её выключения. Другие создаются для каждого потока и уничтожаются, когда поток уничтожается.

### The pc Register (PCR)

Для одного потока, существует один PCR, который создается при запуске потока. PCR хранит адрес выполняемой сейчас инструкции JVM.

### Java Virtual Machine Stacks

Каждый поток в JVM имеет собственный стек, созданный одновременно с потоком. Стек в JVM хранит frames. Cтеки в JVM могут иметь фиксированный размер или динамически расширяться и сжиматься в соответствии с требованиями вычислений.

### Heap

JVM имеет heap (кучу), которая используется всеми потоками виртуальной машины Java. *Куча* - это **область данных** времени выполнения, из которой выделяется память для всех экземпляров и массивов классов. Куча создается при запуске виртуальной машины.

### Method Area

VM имеет область методов, которая является общей для всех потоков. Она хранит структуры для каждого класса, такие как пул констант, данные полей и методов, а также код для методов и конструкторов, включая специальные методы, используемые при инициализации классов и экземпляров, и инициализации интерфейса. Хотя область метода является логически частью кучи, простые реализации могут не обрабатываться сборщиком мусора.

### Run-Time Constant Pool

A run-time constant pool существует для каждого класса или интерфейса в рантайме и представлено constant_pool таблицей в .class файле. Он содержит несколько видов констант: от числовых литералов, известных во время компиляции, до ссылок на методы и поля, которые должны быть разрешены во время выполнения.

### Native Method Stacks

Реализация виртуальной машины Java может использовать обычные стеки, обычно называемые «стеки Си», для поддержки native methods (методов, написанных на языке, отличном от языка программирования Java).

---

## Frames

*Frame* используется для хранения данных и частичных результатов, а также для выполнения динамического связывания, возврата значений для методов и отправки исключений. 
Новый frame создается каждый раз, когда вызывается метод. Frame уничтожается, когда завершается вызов метода, является ли это завершение нормальным или резким (он генерирует неперехваченное исключение). 
Frames выделяются из стека потока, создающего frame. Каждый frame имеет свой собственный массив локальных переменных, свой собственный стек операндов и ссылку на пул констант во время выполнения класса текущего метода. Размеры массива локальных переменных и стека операндов определяются во время компиляции и предоставляются вместе с кодом для метода, связанного с фреймом. Таким образом, размер структуры данных, frame-а зависит только от реализации виртуальной машины Java, и память для этих структур может быть выделена одновременно при вызове метода
