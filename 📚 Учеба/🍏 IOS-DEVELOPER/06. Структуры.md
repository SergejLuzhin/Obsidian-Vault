- [[#Объявление структуры|Объявление структуры]]
	- [[#Объявление структуры#С вычисляемыми свойствами (только геттер)|С вычисляемыми свойствами (только геттер)]]
	- [[#Объявление структуры#С явными геттерами и сеттерами. get{}, set{}|С явными геттерами и сеттерами. get{}, set{}]]
	- [[#Объявление структуры#С явными наблюдателями свойств. willSet{}, didSet{}|С явными наблюдателями свойств. willSet{}, didSet{}]]
- [[#Инициализаторы|Инициализаторы]]
- [[#Модификаторы контроля доступа|Модификаторы контроля доступа]]
	- [[#Модификаторы контроля доступа#internal|internal]]
	- [[#Модификаторы контроля доступа#private|private]]
	- [[#Модификаторы контроля доступа#private(set)|private(set)]]
	- [[#Модификаторы контроля доступа#fileprivate|fileprivate]]
	- [[#Модификаторы контроля доступа#fileprivate(set)|fileprivate(set)]]

--- 
## Объявление структуры 

### С вычисляемыми свойствами (только геттер)

```swift
struct Rectangle {
        var width: Int
        var height: Int

        var area: Int {      //вычисляется на лету
            width * height
        }
    }
```

### С явными геттерами и сеттерами. `get{}`, `set{}`

```swift
struct Book {
    private var _name: String
    var name: String {
        get { _name }   
        set { _name = newValue }
    }

    private var _author: String
    var author: String {
        get { _author }
        set { _author = newValue }
    }

    private var _releaseYear: Int
    var releaseYear: Int {
        get { _releaseYear }
        set {
            print("Release year has been changed from \(_releaseYear) to \(newValue)")
            _releaseYear = newValue }
    }

    init(name: String, author: String, releaseYear: Int) {
        self._name = name
        self._author = author
        self._releaseYear = releaseYear
    }
}
```

Это **вычисляемые свойства** с приватным бэкинг-хранилищем.

Мы храним фактическое значение в приватной переменной (`_name`) и «пропускаем» доступ к нему через публичное свойство name `{ get set }`, где можно добавить логику.

**Такая конструкция нужна для:**
1. Валидации / Нормализации кода
2. Авто-форматирования / очистки
3. Контролирования доступа и инкапсуляции

>Нижнее подчёркивание в имени (`_name`) — **не особенность языка**, а просто **соглашение по имени**. Его часто используют как «бэкинг-поле» для вычисляемого свойства name.

---
### С явными наблюдателями свойств. `willSet{}`, `didSet{}`

==Наблюдатели свойств (property observers)== - `willSet и didSet` не функции, а специальные «хуки» у **хранимых свойств**, которые вызываются соответственно **до** и **после** присваивания.

```swift
struct Person {
    var name: String {
        willSet {
            print("Имя изменится: '\(name)' → '\(newValue)'")
        }
        didSet {
            print("Имя изменилось: было '\(oldValue)', стало '\(name)'")
        }
    }
  
    var age: Int {
        willSet {
            print("Возраст станет \(newValue)")
        }
        didSet {
            if age < 0 { age = oldValue }   // корректируем; наблюдатели повторно не срабатывают
            print("Возраст теперь \(age)")
        }
    }
}
```

- **willSet** — вызывается **до записи** нового значения. Доступен newValue. Нужен для подготовки: отписаться от старого объекта, остановить таймер, залогировать «что будет».
    
- **didSet** — вызывается **после записи**. Доступен oldValue. Нужен для реакции: обновить UI, пересчитать зависимые данные, при необходимости **подкорректировать** значение (как в примере).

---
## Инициализаторы

==Инициализатор (init)== — специальный метод, который создаёт экземпляр и **гарантирует инициализацию всех хранимых свойств**. Инициализаторов может быть **сколько угодно**. У них нет возвращаемого типа и значения; можно перегружать, делать «проваливающийся» (`init?`) и цепочечно вызывать другие инициализаторы через `self.init(...)`.

`Полный инициализатор:`
```swift
struct Person {
    var name: String
    var age: Int

    init(name: String, age: Int) {      // полный init
        self.name = name
        self.age = max(0, age)          // валидация/нормализация
    }
}

let p = Person(name: "Ed", age: 30)
```

`Пустой инициализатор без параметров:`
```swift
struct Person {
    var name: String
    var age: Int

    init() {                            // пустой init
        self.name = "Unknown"
        self.age  = 0
    }
}

let p = Person()
```

---

##  Модификаторы контроля доступа

Модификаторы доступа можно применять не только к свойствам, но и к **функциям структуры**. `а также еще много к чему, но об этом позже`

### internal

Модификатор ==internal== означает, что данное свойство «видно» **везде**, где вы работаете с объектом. Изменит его кто-то или нет, зависит от того, константой или переменной является это свойство. Но прочитать значение точно можно будет в **любом кусочке кода**.

Если мы пометим свойство ключевым словом `internal`, то ничего не изменится, как если бы мы ничего не написали. То есть модификатор `internal` ставится **по умолчанию**:
`internal let name: String == let name: String`

### private

 Модификатор ==private== означает, что свойство **не видно за пределами структуры**. Доступ к нему возможен только из функций внутри структуры. Добавление модификатора `private` к одному из свойств структуры **делает приватным и его дефолтный инициализатор**. Это означает, что вам придётся **самим написать инициализатор**:

```swift
struct Specie {
    private let name: String

    let color: String
    let height: Double

    init(color: String,
         height: Double ) {
        self.color = color
        self.height = height

        name = "Secret"
    }
}
```

Если мы попытаемся **напрямую обратиться** к значению `specie.name`, то получим **ошибку**. 

### private(set)

Модификатор ==private(set)== делает свойство **доступным для чтения извне, но не для записи** извне.

```swift
print(newSpecie.name) //все нормально
newSpecie.name = "New Name" //ошибка
```

### fileprivate

Модификатор ==fileprivate== означает, что поле будет **доступно любому коду в текущем файле**, где описана структура, но недоступно нигде вне этого файла.

### fileprivate(set)

Аналог private(set). Делает поле **доступным для чтения из любого места**, но запись только внутри одного файла.

