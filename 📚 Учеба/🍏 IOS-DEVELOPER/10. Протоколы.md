
---
Создатели языка Swift называют его **протокольно-ориентированным**.

## Что такое протокол

Протокол **определяет** набор свойств и методов, но, в отличие от известных вам классов или структур, **не содержит их реализацию**.

Когда класс, структура или перечисление принимает протокол, то **обязуется реализовать** весь описанный в нём набор свойств и методов.

``` swift
protocol SomeProtocol {
    // тут пишем набор свойств и методов
    // помним, что реализация отсутствует
}

// тут подписываем класс на протокол
// теперь класс должен реализовывать все свойства и методы, которые определил протокол
class SomeClass: SomeProtocol { }

// если есть родительский класс, сначала указываем его, а потом протоколы
class SomeClass: ParentClass, SomeProtocol { }

// если класс принимает более одного протокола, то перечисляем их через запятую
class SomeClass: ParentClass, SomeProtocol, AnotherProtocol { }
```

Протокол определяет **название, тип и доступность** для чтения и изменения (помним про [[06. Структуры#С явными геттерами и сеттерами. get{}, set{}|геттеры и сеттеры]]):
```swift
protocol SomeProtocol {
    // это свойство доступно для чтения и изменения
    var mustBeSettable: Int { get set }
    
    // это свойство доступно только для чтения
    var doesNotNeedToBeSettable: Int { get }

    // а вот пример статической переменной
    static var someTypeProperty: Int { get set }
}
```

## Протоколы как типы данных

```swift 
struct Spaceship {
    var name: String
    var captain: Captain
    var pilot: PilotProtocol?
}
```

Поле `pilot` имеет тип протокола. На должность пилота подойдёт не только объект конкретного класса, но и любой другой тип данных, который поддерживает протокол пилота.

### Протокол как аргумент функции

Протокол также может быть типом у параметра функции.

```swift
mutating func addCrewMember(_ crewMember: CrewMemberProtocol) {
	crew.append(crewMember)
}
```

## Композиция протоколов

С помощью композиции можно **объединять** несколько протоколов в один. Протокол может быть пустым.

```swift
// этот протокол сочетает в себе сразу несколько других
protocol CrewMemberProtocol: PilotProtocol, EngineerProtocol { }
```

```swift
var crew: [CrewMemberProtocol]
==
var crew: [PilotProtocol & EngineerProtocol]
```

## Проверка значений и приведение типов 

Как в случае и с структурами, протоколы можно проверять на соответствие и приводить к нужному типу при помощи операторов `is` и `as`. 

 Операторы:
- is — **проверка типа/конформности** → Bool.
- as — **безопасный апкаст** (к суперклассу/протоколу) и **бриджинг** (String ↔ NSString и т.п.).
- as? — **условное приведение** (даст Optional).
- as! — **форс-приведение** (крэш при неудаче).

Примеры для базовых структур:
```swift
let items: [Any] = [1, "hi", 3]

// Проверка:
if items[0] is Int { /* true */ }

// Условное приведение:
let maybeInt = items[1] as? Int     // nil
let s = items[1] as? String         // "hi"

// Форс (опасно):
let i: Int = items[0] as! Int

// Апкаст к протоколу/суперклассу:
class Animal {}
class Dog: Animal {}
let a: Animal = Dog() as Animal     // as (гарантированно)
```


Приведение типа `CrewMemberProtocol` к `Captain`.
```swift
struct Spaceship {
    ...

    var crew: [CrewMemberProtocol]
    
    func crewWorks() {
        crew.forEach { crewMember in // 1
            if let captain = crewMember as? Captain { // 2
                captain.lead() // 3
            } else { // 4
                crewMember.fix() 
            }
        }
    }
}
```

## Расширение протоколов

**Расширение протокола** добавляет общую реализацию (методы/вычисляемые свойства/инициализаторы/статические члены) для **всех** типов, которые этому протоколу соответствуют. Хранимые свойства добавлять нельзя.

```swift
extension CrewMemberProtocol {
    func doSomeWork() {
        print("I'm working!")
    }
}
```

Теперь все типы, подписанные на протокол`CrewMemberProtocol` могут выполнять функцию `doSomeWork()` и не нужно прописывать данный функционал отдельно для каждого типа.