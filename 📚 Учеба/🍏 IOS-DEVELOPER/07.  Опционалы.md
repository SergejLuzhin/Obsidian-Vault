---

---
- [[#Что такое опционалы?|Что такое опционалы?]]
	- [[#Что такое опционалы?#Объявление опционала|Объявление опционала]]
	- [[#Что такое опционалы?#Как устроены опционалы "под капотом"?|Как устроены опционалы "под капотом"?]]
- [[#Распаковка опицонала (unwrapping)|Распаковка опицонала (unwrapping)]]
	- [[#Распаковка опицонала (unwrapping)#Механизм optional binding|Механизм optional binding]]
		- [[#Механизм optional binding#Конструкция guard|Конструкция guard]]
		- [[#Механизм optional binding#Shadowing переменной|Shadowing переменной]]
		- [[#Механизм optional binding#Оператор nil-coalescing (соединение с nil)|Оператор nil-coalescing (соединение с nil)]]
	- [[#Распаковка опицонала (unwrapping)#Механизм force unwrapping|Механизм force unwrapping]]
	- [[#Распаковка опицонала (unwrapping)#Механизм implicit unwrapping|Механизм implicit unwrapping]]
- [[#Связывание опционалов|Связывание опционалов]]
	- [[#Связывание опционалов#Цепочка опционалов|Цепочка опционалов]]
		- [[#Цепочка опционалов#Небезопасные распаковки в цепочке|Небезопасные распаковки в цепочке]]


---
## Что такое опционалы?

Это возможность языка, позволяющая разработчику сообщить программе, что данная переменная может **либо иметь значение** указанного типа, **либо нет**.

### Объявление опционала

Превратить любой тип данных в опционал просто — достаточно лишь поставить знак вопроса `?` после названия типа: `String?`, `Int?` и так далее.

```swift
var pi: Double?
print(pi) //nil, но ошибки нет, программа работает дальше

pi = 3.14
print(pi) //Optional(3.14)
```

### Как устроены опционалы "под капотом"?

Опционал — это **перечисление** с двумя кейсами:

- `none` означает, что в коробке пусто: значения нет.
- `some` — значение в коробке; в опционале это ассоциированное значение для кейса `some`.

 ``` swift
 enum Optional<Wrapped> {
	 case none
	 case some(Wrapped)
}
 ```
 `Wrapped` — это тип данных, который мы кладём в коробку `Optional`, например

---

##  Распаковка опицонала (unwrapping)

Чтобы использовать значение **без обёртки**, нужно его достать из опционала. Этот процесс называется ==«распаковка» (англ. unwrapping).==

Есть **три** основных механизма распаковки:
- optional binding,
- force unwrapping,
- implicit unwrapping.

###  Механизм optional binding

_Optional binding_ («связывание опционала») позволяет вам проверить, есть ли в опционале значение. Если да, то мы сможем **привязать это значение** к временной переменной или константе.

```swift
var message: String?
if let value = message {
    print(value)
}
```

`Есть и более простой способ записи:`
```swift
var message: String?
if let message {
    print(message)
}
```

Данный вид распаковки **самый безопасный**.

#### Конструкция guard

Из-за того, что переменная `value` доступна **только в области видимости** `if`, нам нужно будет поместить всё использование этой переменной внутрь этой области видимости. А это далеко не всегда удобно.

По сути, `guard` чем-то **похожа на** `if`, только это `if` **наоборот**. Вот её синтаксис:

```swift
guard <...> else { <...> } 

или на реальном примере:

guard let value = message else { <...> } 
```
`В блоке else - действие, которое выполнится, если условие не выполнено`

Распакованное значение `value` **можно  использовать везде** после конструкции `guard`.

```swift
var message: String?
prepare(message)

func prepare(_ message: String?) {
    guard let value = message else { //можно просто guard let message else
        return //если значение пустое, то прекращаем выполнение функции
    }
    print(value.uppercased())
}
```

Конструкция `guard` может проверять **несколько значений** за раз:

```swift
func sum(a: Int?, b: Int?) -> Int? {
        guard
            let a = a,
            let b = b
        else {
            return nil
        }
        
        return a + b
}
```

#### Shadowing переменной

```swift
if let message = message {
    ...
}

или

guard let message = message else {
    return
}
...
```

Здесь, внутри тела `if`, вы можете обращаться к `message`, и это **не будет** опционалом.

==Не совсем понятно, [[❓ Вопросы#В чем разница между shadowing'ом переменной и optional binding?|в чем разница между shadowing'ом переменной и optional binding?]]==

#### Оператор nil-coalescing (соединение с nil)

 Оператором `??`  можно воспользоваться для подстановки значения по умолчанию, когда искомая переменная пуста.

``` swift
var message: String?
print(message ?? "Сообщение не получено")
```

### Механизм force unwrapping

*Данный механизм является **небезопасным** и существует лишь для обратной совместимости с языком Objective-C. Его лучше **не использовать**, а во многих проектах он и вовсе **запрещен**!*

**Force unwrapping** («принудительная распаковка») и правда **принудительно** достаёт из опционала значение, не проверяя, пустое оно или нет. Делается это путём добавления восклицательного знака `!` после переменной-опционала:

```swift
var message: String?
message = "Hello, World"
print(message!) // Hello, World

Однако

var message: String?
print(message!) // Fatal error: Unexpectedly found nil while unwrapping an Optional value
```

### Механизм implicit unwrapping

*Данный механизм **не желателен** к использованию, как и force unwrapping!*

**Implicit unwrapping** («неявная распаковка»). Для активизации этого механизма нужно  при создании переменной поставить после типа восклицательный знак `!`

```swift
var temperature: Int!

print(temperature) // выведет nil
temperature = 18
print(temperature) // выведет Optional(18)
```

Теперь Swift не ругается, когда мы используем переменную до инициализации, и позволяет нам использовать её со значением `nil`. Однако это все равно может привести к **критической ошибке**, при дальнейших действиях с переменной.

---
## Связывание опционалов

Можно поставить знак вопроса `?` перед точкой: `message?.count`. Тогда Swift пойдёт смотреть значение `count`, только если в `message` содержится значение не `nil`.

``` swift
var message: String?
print(message?.count) //nil
```

```swift
var message: String?
message = "Hello"
print(message?.count) //Optional(5)
```

### Цепочка опционалов

**Цепочка** для функций и свойств:

```swift
print(message.subject?.uppercased())

print(message.subject?.count)
```

Если все сообщение тоже будет опционального типа:
```swift
let message: Message? = Message(subject: nil, text: "Hello", date: "01.01.2000")
print(message?.subject?.count)
```

**Что здесь происходит?**

1. Swift проверяет, есть ли значение в `message`. Если да, то распаковывает его. Если нет — цепочка прерывается, и результатом всего выражения будет `nil`.
    
2. Swift проверяет, есть ли значение в `message.subject`. Если да, то распаковывает его. Если нет — цепочка прерывается, и результатом всего выражения будет `nil`.
    
3. Swift берёт значение `message.subject.count` и делает его **опциональным** результатом всего выражения. Опциональным — потому что цепочка могла в любой момент прерваться, что означало бы, что `count` пуст.

Это и есть **цепочка опционалов**. Если что-то из этой цепочки имеет опциональный тип, то вся цепочка имеет опциональный тип.

 Пример комбинации цепочек опционалов и nil-coalescing:
```swift
func explore(planet: Planet?) {
        print("distance=\(planet?.distance.description ?? "<planet not found>")")
        print("color=\(planet?.color ?? "<color not found>")")
    }
```

#### Небезопасные распаковки в цепочке

```swift
print(message!.subject)
```

*Принудительная распаковка цепочек опционалов также **небезопасна** и **нежелательна**!*
